exit
resp.sort_by { |element| element["id"]}
resp.sort_by { |element| element.id}
resp.sort_by { |element| element.login}
resp.sort_by { |element| element}
resp.sort_by { |element| element.id}
resp.sort_by { |element| element.keys.first }
exit
JSON.parse(response.body).sort_by! { |hsh| hsh[:id] }
resp.sort_by! { |hsh| hsh[:id] }
resp.sort_by { |hsh| hsh[:id] }
resp.sort_by { |hsh| hsh[:a] }
resp.sort_by { |hsh| hsh[:login] }
resp.sort_by { |hsh| hsh[:id] }
resp[0].class
resp[0]
resp
resp.to_h
resp.class
resp.sort_by(&:id).class
resp.sort_by(&:id)
exit
i.deep_stringify_keys!
i
exit
exiot
resp.sort_by{|e| e[:id]}
resp.sort_by{|e| -e[:id]}
resp.sort_by{|e| e[:id]resp.sort_by{|e| -e[:id]}}
resp.sort_by{|e| e[:id]}
resp.order! 'id'
resp.sort_by(&:id)
resp
resp.class
resp.CLASS
resp.order('created_at DESC')
exit
resp
JSON.parse(response.body)
exit
EXIT
resp
JSON.parse(response.body)
exit
resp
JSON.parse(response.body)
JSON.parse(response.body).count
resp.count
JSON.parse(response.body).count
JSON.parse(response.body)
exit
resp
JSON.parse(response.body)
exit
put '/actors'
put '/actors/1'
put '/actors'/1
put '/actors'
params
put '/actors', params
exit
put '/actors', params
exit
exut
EXIT
resp
JSON.parse(response.body)
hola.equal?(resp)
hola.equal(resp)
hola = JSON.parse(response.body)
exit
resp
JSON.parse(response.body)
expect(JSON.parse(response.body)).to eq resp
JSON.parse(response.body)
response.status
exit
@events
@actor
exit
params
exit
expect(JSON.parse(response.body)).to eq resp.deep_stringify_keys
resp.deep_stringify_keys
JSON.parse(response.body)
exit
JSON.parse(response.body)
resp.deep_stringify_keys
exit
resp.deep_stringify_keys
JSON.parse(response.body)
exit
@event.created_at.strftime('%a, %d %b %Y %H:%M:%S')
@event.created_at.change(:usec => 0)
@event.created_at
Time.parse(@event.created_at)
@event.created_at.to_json
@event.created_at
exit
JSON.parse(response.body)exit
JSON.parse(response.body)
resp.deep_stringify_keys
exit
resp.deep_stringify_keys
JSON.parse(response.body)
exit
resp.deep_stringify_keys
JSON.parse(response.body)
exit
response.body
response
exit
response.body
JSON.parse(response.body)
response.status
response.class
response
exit
@event.actor.id
@event.actor
@event
exit
resp.deep_stringify_keys
JSON.parse(response.body)
expect(response.status).to eq 200
expect(response.status).to eq 200\
response.status
exit
get '/events/1'
exit
get '/events/1'
exit
get '/events/1'
resp.class
resp
exit
@repo
@actor
params.permit(:id).merge(actor_id: @actor.id, repo_id: @repo.id, event_type: params["type"])
params
exit
@repo
exit
Repo.find_or_create_by(params["repo"])
params["repo"]
exit
response.status
response
params
parms
exit
params
exit
params
@event = Event.new(event_params)
Event.new(event_params)
event_params
exit
params.permit(:id).merge(actor_id: @actor.id, repo_id: @repo.id, event_type: params["type"])
params.permit(:id).merge(actor_id: @actor.id, repo_id: @repo.id, event_type: :type)
params.permit(:id, :type, :actor)
params.permit(:id, :type)
params.permit(:id, :_type)
params.require(:event).permit(:id, :_type)
params.require(:event).permit(:id, :event_type)
exit
params
exit
Event.new(event_params)
exit
Event.new(event_params)
event_params
exit
@event = Event.new(event_params).errors
@event = Event.new(event_params).ererors
@event = Event.new(event_params)
Event.new(event_params)
Event.create(event_paramsD)
Event.createQ(event_paramsD)
Event.create(event_params)
Event.new(event_params)
event_params
exit
event_params
Event.new(event_params)
exit
event_params
Event.new(event_params)
exit
params.require(:event).permit(:id, :type, :actor_id).merge(actor_id: @actor.id, repo_id: @repo.id)
params.require(:event).permit(:id, :type, :actor_id).merge(actor_id: @actor.id, repo_id: @repo_id)
params.require(:event).permit(:id, :type, :actor_id)
params.permit(:id, :type, :actor_id)
params.permit(:id, type: "asd")
params.permit(:id, type: asd)
params.permit(:id, type: )
params.permit(:id, type)
params.permit(:id, :type)
params.permit(:id, :type)params.permit(:id, :type)
params.permit(:id, :type)
params.permit(:id, :type, "actor")
params.permit(:id, :type, "actor").class
params.permit(:id, :type).class
params.permit(:id, :type)
params.permit(:id, :type, :actor["id"])
params.permit(:id, :type, :actor)
params.permit(:id, :type)
params.permit(:id, :as)
params.permit(:id)
params.permit!
@actor
@repo
exit
@actor
@repo
params
exit
Repo.create(id: params["repo"]["id"], name: params["repo"]["name"], url: params["repo"]["url"])
Repo.create(id: params["Repo"]["id"], name: params["repo"]["name"], url: params["repo"]["url"])
params["repo"]["id"]
params["repo"]
@repo
@actor
params.permit!
params.permit(:id, :type)
params.permit(:id, :type, @actor)
params.permit(:id, :type, actor)
params.permit(:id, :type)
arams.permit(:id, :type)
exit
params
params.permit(:id, :type, :actor, :repo)
params.permit(:id, :type, actor, :repo)
params.permit(:id, :type, :actor, :repo)
params.permit!(:id, :type, :actor, :repo)
params.permit!
params.require(:event).permit!
params.permit!
params.permit(:id, :typeparams.permit!)
params.permit(:id, :type, :actor, :repo)
params
params.permit(:id, :type, :actor, :repo)
params.permit(:id, :type, :actor_id, :repo)
params.permit(:id, :type, :actor, :repo)
params.permit(:id, :type, :actor)
params.permit(:id, :type)
params.require(:event).permit(:id, :type)
params.require(:event).permit(:id, :type, :actor)
params.require(:event).permit(:id, :type, :actor_id)
params.require(:event).permit(:id, :type, actor_id)
params.require(:event).permit(:id, :type)
params.require(:event).permit(:id, :type).class
params.require(:event).permit(:id, :type)
params.require(:event).permit(:id, :type
exit
params.require(:event).permit(:id, :type)
